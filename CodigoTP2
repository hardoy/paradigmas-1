class Jugador {
	var skills
	var peso
	var fuerza
	var escoba
	var tieneLaQuaffle = false
	var equipo
	constructor(_skills,_peso,_fuerza,_escoba) {
		skills = _skills
		peso = _peso
		fuerza = _fuerza
		escoba = _escoba
	}
	
	// Getters&Setters
	method skills() {
		return skills
	}
	method modificarSkills(num){ skills =+ num }
	method peso() {
		return peso
	}
	method fuerza() {
		return fuerza
	}
	method escoba() {
		return escoba
	}
	method velocidadDeEscoba() {
		return escoba.velocidadEscoba()
	}
	method saludDeEscoba() {
		return escoba.saludEscoba()
	}
	method tieneLaQuaffle(){
		return tieneLaQuaffle 
	}
	method equipo(){
		return equipo
	}
	method asignarEquipo(equipoNuevo){
		equipo = equipoNuevo
	}
	
	// Calculos para habilidad
	method manejoDeEscoba() {
		return skills / peso
	}
	method velocidad() {
		return escoba.velocidadEscoba() * self.manejoDeEscoba()
	}
	method habilidad() {
		return self.velocidad() + skills
	}
	
	// Metodos para facilitar la busqueda de un jugador en un equipo
	method esGroso(restoDeEquipo) {
		return self.habilidad() > restoDeEquipo.promedioHabilidad() && self.velocidad() >= mercadoDeEscobas.velocidadMinimaParaSerGroso()
	}
	method esJugadorEstrella(equipoRival){
		return equipoRival.jugadores().all({jugadorRival => self.lePasaElTrapoA(jugadorRival)})
	}
	method esMasVelozQue(listaDeJugadores){ // no recibe equipo
		return listaDeJugadores.all({jugador => self.velocidad() >= jugador.velocidad()})
	}
	method esMasHabilidosoQue(listaDeJugadores){ // // no recibe equipo
		return listaDeJugadores.all({jugador => self.habilidad() >= jugador.habilidad()})
	}
	
	// Metodos para el juego
	method lePasaElTrapoA(otroJugador) {
		return self.habilidad() >= 2.0 * otroJugador.habilidad()
	}
	method bludgereado(equipo) {
		skills -= 2
		escoba.recibeGolpe()
		tieneLaQuaffle = false
	}
	method puedeTenerLaQuaffle() = return false
	method ganaLaQuaffle(listaDeJugadores){}
	method pierdeLaQuaffle(){}
	method esBlancoUtil(equipoRival){ return self.esJugadorEstrella(equipoRival) || self.tieneLaQuaffle() }
	method hacerJugada(equipo, rival){}
}



// Cazador (en construccion)
class Cazador inherits Jugador {
	var punteria
	constructor(_skills,_peso,_fuerza,_escoba,_punteria) = super(_skills,_peso,_fuerza,_escoba) {
		punteria = _punteria
	}
	method punteria() {
		return punteria
	}
	override method habilidad() {
		return punteria * fuerza + super()
	}
	override method puedeTenerLaQuaffle()= return true
	override method ganaLaQuaffle(listaDeJugadores){
		tieneLaQuaffle = true
	}
	override method pierdeLaQuaffle(){
		tieneLaQuaffle = false
	}
	
}

// Golpeador (en construccion)
class Golpeador inherits Jugador {
	var punteria
	constructor(_skills,_peso,_fuerza,_escoba,_punteria) = super(_skills,_peso,_fuerza,_escoba) {
		punteria = _punteria
	}
	method punteria() {
		return punteria
	}
	override method habilidad() {
		return punteria + fuerza + super()
	}
	override method hacerJugada(equipo,rival){
		if( self.elegirBlancoUtil(rival).reflejos() < self.punteria() ){
			self.modificarSkills(5)
			self.elegirBlancoUtil(rival).bludgereado(rival)
		}
	}
	method elegirBlancoUtil(rival){
			return rival.jugadorUtiles().find({unJugador => unJugador.esMasHabilidosoQue(rival.jugadorUtiles())})
	}
}

// Guardian (en construccion)
class Guardian inherits Jugador {
	constructor(_skills,_peso,_fuerza,_escoba) = super(_skills,_peso,_fuerza,_escoba)
	override method habilidad() {
		return self.reflejos() + fuerza + super()
	}
	method reflejos() {
		return 20 + self.velocidad() * skills / 100
	}
	override method puedeTenerLaQuaffle()= return true
	override method ganaLaQuaffle(listaDeJugadores){
		listaDeJugadores.remove(self)
		listaDeJugadores.find({jugador => jugador.esMasHabilidosoQue(listaDeJugadores)}).ganaLaQuaffle(listaDeJugadores)
	} // este metodo no esta funcionando, si pongo listaDeJugadores.remove(self).find... tampoco funciona. En el ultimo caso es como si el remove removiera pero no devuelve una lista (cuando lo probe devolvio null)
}

// Buscador (en construccion)
class Buscador inherits Jugador {
	var vision
	var actividad = busqueda
	var tunosBuscando = 1
	var metrosParaAtrapar = 5000
	constructor(_skills,_peso,_fuerza,_escoba,_vision) = super(_skills,_peso,_fuerza,_escoba) {
		vision = _vision
	}

	method actividad()= return actividad
	method cambiarActividad(nuevaActividad){ actividad = nuevaActividad }
	method metrosParaAtraparSnitch() = return metrosParaAtrapar
	method reducirMetrosParaAtraparSnitch(){ metrosParaAtrapar =- self.velocidad() * 2 }
	method atrapaLaSnitch(equipo) = equipo.ganaPuntos(150)

	override method habilidad() {
		return self.reflejos() * vision + super()
	}
	method reflejos() {
		return self.velocidad() * skills / 100
	}
	method reiniciarBusqueda(){
		actividad = busqueda
		tunosBuscando = 1
		metrosParaAtrapar = 5000
	}
	override method bludgereado(equipoPropio){
		super(equipoPropio)
		if(self.esGroso(equipoPropio)){
			aturdido.guardarActividadAnterior(actividad)
			actividad = aturdido
		}
		else{self.reiniciarBusqueda()}
	}
	override method hacerJugada(equipo, rival){ actividad.realizarla(equipo, self) }
	override method esBlancoUtil(equipo){
		return super(equipo) || (actividad === persecucion && metrosParaAtrapar < 1000)
		
	}
}
object busqueda{
	method realizarla(equipo, unJugador){
	// en construccion	
	}
}
object persecucion{
	method realizarla(equipo, unJugador){
		unJugador.reducirMetrosParaAtraparSnitch()
		if(unJugador.metrosParaAtrapar() <= 0) { 
			unJugador.atrapaLaSnitch(equipo)
			unJugador.modificarSkills(30)
		}
	}
}
object aturdido{
	var estadoAnteriorASerGolpeado
	method realizarla(equipo, unJugador){ unJugador.cambiarActividad(estadoAnteriorASerGolpeado) }
	method guardarActividadAnterior(actividad){ estadoAnteriorASerGolpeado = actividad }
}


// equipo
class Equipo {
	var jugadores
	var puntos = 0
	constructor(_jugadores) {
		jugadores = _jugadores
		jugadores.map({ unJugador => unJugador.asignarEquipo(self) })
	}
	method jugadores() {
		return jugadores
	}
	method puntos() = return puntos
	method ganarPuntos(nuevosPuntos) { puntos =+ nuevosPuntos}
	method promedioHabilidad() {
		return jugadores.sum({unJugador => unJugador.habilidad()}) / jugadores.size() 
	}
	method jugadoresGrosos() {
		return jugadores.filter({unJugador => unJugador.esGroso(self)})
	}
	method jugadorUtiles() {
		return jugadores.filter({unJugador => unJugador.esBlancoUtil(self)})
	}
	method tieneJugadorEstrellaParaJugarContra(otroEquipo) {
		return jugadores.any({unJugador => unJugador.esJugadorEstrella(otroEquipo)})
	}
	method tieneLaQuaffle(){
		return jugadores.any({unJugador => unJugador.tieneLaQuaffle()})
	}
	method jugadoresQuePuedenTenerQuaffle(){
		return jugadores.filter({unJugador => unJugador.puedeTenerLaQuaffle()})
	}
	method jugadorMasVeloz(listaDeJugadores){
		return listaDeJugadores.find({unJugador => unJugador.esMasVelozQue(listaDeJugadores)})
	}
	method ganaLaQuaffle(){
		if(!(self.tieneLaQuaffle())){
			self.jugadorMasVeloz(self.jugadoresQuePuedenTenerQuaffle()).ganaLaQuaffle(self.jugadoresQuePuedenTenerQuaffle())
		}
	}
	
}

// escobas
object mercadoDeEscobas {
	var velocidadMinimaParaSerGroso
	method velocidadMinimaParaSerGroso() {
		return velocidadMinimaParaSerGroso
	}
	method velocidadMinimaParaSerGroso(nuevaVelocidad) {
		velocidadMinimaParaSerGroso = nuevaVelocidad
	}
}
class Nimbus {
	var modelo
	var salud
	constructor(_modelo,_salud) {
		modelo = _modelo
		salud = _salud
	}
	method velocidadEscoba() {
		return (80 - (new Date().year() - modelo)) * salud / 100
	}
	method saludEscoba() {
		return salud
	}
	method recibeGolpe() {
		salud -= 10
	}
}
object saetaDeFuego {
	method velocidadEscoba() {
		return 100
	}
	method saludEscoba() {
		return 100
	}
	method recibeGolpe() {
	}
}

// suerte
object suerte {
    var tipoDeSuerte = suerteReal
    method tipoDeSuerte(_tipoDeSuerte){
   	 tipoDeSuerte = _tipoDeSuerte
    }
    method tieneSuerte(){
   	 return tipoDeSuerte.tieneSuerte()
    }
}

object suerteReal{
    method tieneSuerte() = (1..5).anyOne() == 1
}

object malaSuerte{
    method tieneSuerte() = false
}

object buenaSuerte{
    method tieneSuerte() = true
}
